<!-- build time:Tue Jul 26 2022 09:40:40 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-HK"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="2022" href="https://fygod1999.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="2022" href="https://fygod1999.github.io/atom.xml"><link rel="alternate" type="application/json" title="2022" href="https://fygod1999.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Inconsolata:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="青训营,课前笔记,SQL optimizer"><link rel="canonical" href="https://fygod1999.github.io/2022/07/22/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/"><title>SQL查询优化器浅析（课前） - 大数据基础班 - 盲人摸象 | Scarecrow = 2022</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">SQL查询优化器浅析（课前）</h1><div class="meta"><span class="item" title="創建時間：2022-07-22 19:13:16"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">發表於</span> <time itemprop="dateCreated datePublished" datetime="2022-07-22T19:13:16+08:00">2022-07-22</time> </span><span class="item" title="本文字數"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字數</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="閱讀時長"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">閱讀時長</span> <span>12 分鍾</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切換導航欄"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Scarecrow</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.fygod.xyz/uploads/2022/07/12/1/1657612999/rpRvLps4_CP77-KV-en.jpg"></li><li class="item" data-background-image="https://cdn.fygod.xyz/uploads/2022/07/23/1/1658534263/fBN59GcH_wallhaven-28mpg6-compressed.jpg"></li><li class="item" data-background-image="https://cdn.fygod.xyz/uploads/2022/07/15/1/1657848213/LvvNNYOD_wallhaven-579ky3-compressed.jpg"></li><li class="item" data-background-image="https://s1.328888.xyz/2022/07/19/lkmU7.jpg"></li><li class="item" data-background-image="https://cdn.fygod.xyz/blog/nest/ZYUoUTGa_wallhaven-rdp3q7-compressed.jpg"></li><li class="item" data-background-image="https://s1.328888.xyz/2022/07/19/lbedo.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首頁</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/" itemprop="item" rel="index" title="分類於 盲人摸象"><span itemprop="name">盲人摸象</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E7%8F%AD/" itemprop="item" rel="index" title="分類於 大数据基础班"><span itemprop="name">大数据基础班</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-HK"><link itemprop="mainEntityOfPage" href="https://fygod1999.github.io/2022/07/22/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="fygod"><meta itemprop="description" content=", 孤舟蓑笠翁，獨釣寒江雪"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="2022"></span><div class="body md" itemprop="articleBody"><h1 id="大数据体系和sql"><a class="anchor" href="#大数据体系和sql">#</a> 大数据体系和 SQL</h1><p><span id="more"></span></p><h2 id="火山引擎"><a class="anchor" href="#火山引擎">#</a> 火山引擎</h2><p>例子来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc29odS5jb20vYS81NTE2NjIwNDBfMzU1MTQw">大规模机器学习平台架构设计</span></p><h3 id="计算"><a class="anchor" href="#计算">#</a> 计算</h3><p>计算方面体现在高性能计算，需要考虑的因素</p><ul><li>新硬件：CPU，GPU，多种类型网卡</li><li>虚拟化产生损耗：网络和容器会进行一定的虚拟化，存储的分层池化也会带来负载均衡的问题</li><li>繁多的分布式训练框架：由于机器学习平台的用户很多，并且不同任务依赖的分布式训练框架也不同（数据并行的框架，模型并行的框架，HPC 框架，其他框架），不同训练框架有各自的调度和资源要求，给底层基础设施带来很多挑战</li></ul><h3 id="存储"><a class="anchor" href="#存储">#</a> 存储</h3><p>对于任何一个系统，存储都是必不可少的，而对于机器学习来说，面临的挑战也有很多</p><ul><li>高性能和扩展性：随着硬件的计算性能越来越好，为满足读数据的高吞吐量，对于存储的要求非常高，比如需要面对达上百 Gb/s 的单租户带宽吞吐以及很小的延迟，存储的容量也是高达 PB 级别。为了提升模型训练的效率，需要数千个计算实例能同时访问的高性能共享存储。</li><li>易用性和安全性：对于用户而言，最重要的就是简单方便，能够传输通畅，数据上下云，部分数据对安全性也有要求，所以需要隔离存储；在使用框架的时候为了能够读写存储能够像读本地文件一样方便，就需要存储接口友好，代码零修改，兼容 POSIX</li><li>成本：尽可能低的成本</li></ul><h3 id="调度"><a class="anchor" href="#调度">#</a> 调度</h3><p>基于高性能的硬件，调度首先需要对资源（计算 + 存储）进行池化，火山引擎机器学习平台有一个大的计算池，里面有大量的 GPU 和 CPU，在保证不同用户计算容器间的隔离前提下，不同客户共享整个资源池，从而提高集群的利用率。</p><p>机器学习的调度需求比较复杂。比如一次分布式训练，有 Worker、Server 和 Scheduler 角色的实例。在调度时，它需要 Gang 调度的能力，所有实例（或其中某一种角色的实例）要么都起来，要么都不起来。同时在训练过程中还需要网络的亲和性。例如同一个分布式训练的容器，申请到的资源能在一台机器肯定是最好。申请多台机器时，这些机器之间的网络连接肯定是越近越好。所以在调度上我们有一些相应的调度策略，包括 多队列调度（排队、抢占）、Gang 调度、堆叠调度等。</p><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-22T14:26:10.png" alt=""></p><h3 id="应用"><a class="anchor" href="#应用">#</a> 应用</h3><p>分布式训练，加速方式主要从计算，通信，显存三个角度考虑</p><ul><li>计算：因为训练一般都用 GPU，火山引擎有一个高性能算子库，自主研发了很多中细粒度高性能算子，它们的性能往往较于好的开源实现有非常明显的提升</li><li>通信：火山开通了 BytePS 通信框架，同时利用了 CPU 和 GPU 两种异构资源来加速通信，在对拓扑的探测上做了细致的智能优化，并且支持异步和同步两种训练模式</li><li>显存：主要针对超大模型场景，开源了 veGiantModel，支持混合并行的策略，包括数据并行，Tensor 并行和流水线并行；可根据参数量、计算量自动切分流水线。veGiantModel 的底层是基于 BytePS 做加速的。</li></ul><h2 id="批式计算和流式计算"><a class="anchor" href="#批式计算和流式计算">#</a> 批式计算和流式计算</h2><table><thead><tr><th><strong>流式计算</strong></th><th><strong>批式计算</strong></th></tr></thead><tbody><tr><td>特性</td><td>对数据流进行处理，实时计算</td><td>统一收集数据，存储到数据库中，然后对数据进行<strong>批量处理</strong></td></tr><tr><td>时效性</td><td>实时计算，低延迟</td><td>非实时，高延迟</td></tr><tr><td>数据特征</td><td>数据一般是动态的，无边界的</td><td>数据一般是静态数据</td></tr><tr><td>应用场景</td><td>实时场景，时效性高，比如实时推荐，业务监控</td><td>时效性不用很高，离线计算，数据分析，离线报表</td></tr><tr><td>运行方式</td><td>流式计算的任务是持续进行的</td><td>批量计算一次性完成</td></tr></tbody></table><p><em>这个就好比分组加密和流密码，分组加密就是批式计算，等着块生成了统一处理，而流密码则实时处理。</em></p><h2 id="交互式分析引擎"><a class="anchor" href="#交互式分析引擎">#</a> 交互式分析引擎</h2><h3 id="背景"><a class="anchor" href="#背景">#</a> 背景</h3><p>在开源大数据领域，交互式引擎是后来才出现的，最初，<strong>大数据领域数据处理引擎以 MapReduce 为主</strong>，但是 MapReduce 引擎采用了批处理设计理念，数据处理性能不行</p><ul><li>IO 密集型：Map 阶段中间结果写磁盘，Reduce 阶段写 HDFS，多个 MapReduce 作业之间通过一个共享存储系统 HDFS 交换数据</li><li>任务调度和启动开销大：大量任务需要分布式调度到各个节点上，且每个任务需要启动一个 Java 虚拟机运行</li><li>无法充分利用内存：MapReduce 是十多年前提出的分布式技术，当时内存的价格很高，所以设计理念是充分利用磁盘，而如今不再如此，新型计算引擎可以尝试通过内存加速</li><li>Map 端和 Reduce 端均需要排序：这是其本身设计理念决定的，使得其无法很好地应对交互式处理场景</li></ul><p>为了克服 MapReduce 地性能缺陷，Google 提出了<strong>新型交互式计算引擎 Dremel</strong>，它构建于 Googel 地 GFS（Google File System）等系统之上，支撑了 Google 的数据分析服务 BigQuery 等诸多服务。Dremel 的技术亮点主要有两个：一个是<strong>采用了 MPP 架构，使用了多层查询树</strong>，使得任务可以在数千个节点上并行窒息感和聚合结果；二是实现了<strong>嵌套数据的列式存储</strong> ，避免读取不必要的数据，大大减少网络和磁盘 IO。</p><h3 id="分类"><a class="anchor" href="#分类">#</a> 分类</h3><p>交互式计算引擎是<strong>具备交互式分析能力</strong>的分布式大数据计算引擎，它常用于<strong> OLAP 场景</strong>。OLAP 有很多实现方法，根据存储数据的方式不同可以分为 ROLAP，MOLAP，HOLAP 等。</p><ul><li>ROLAP：基于关系型数据库的 OLAP 实现（Relational OLAP）。它以<strong>关系型数据库</strong>为核心，以关系型结构进行多维度的表示和存储。它将多维结构划分为两类表：一类是<strong>事实表</strong>，用来<strong>存储数据和纬度关键字</strong>；另一类是<strong>纬度表</strong>，即对每个<strong>纬度至少使用一个表来存放纬度层次</strong>，成员类别等纬度描述信息。ROLAP 的最大好处是可以实时的从源数据中获取最新数据更新，以保持数据实施性，缺点在于运算效率比较低，用户等待响应时间比较长。</li><li>MOLAD：基于多维度的 OLAP 实现（Multidimensional OLAP）。它以<strong>多位数据组织方式</strong>为核心，使用多纬数据存储数据。多维数组在存储系统中形成 <code>数据立方体（Cube）</code> 的结构，此结构是<strong>经过高度优化的</strong>，可以<strong>最大程度地提高查询能力</strong>。MOLAP 的优势在于借助数据多纬预处理显著提高运算效率，主要额缺陷在于占用存储空间和数据更新有一定延滞。</li><li>HOLAP：基于混合组织的 OLAP 实现（Hybrid OLAP），用户可以<strong>根据自己的业务需求</strong>，选择哪些模型采用 ROLAP，哪些采用 MOLAP。一般来说，将不常用或需要灵活定位的分析使用 ROLAP 方式，而常用，常规模型采用 MOLAP 实现。</li></ul><p><em>Impala 和 Presto 可用于 ROLAP 场景，而 Druid 和 Kylin 常用于 MOLAP 场景。也有人将 Druid 规划到 “HOLAP” 范畴，因为它不会进行预计算，因此是一种 “ROLAP”，但同时它此用了列式存储，且为非关系型模型，因此也是一种 “MOLAP”。</em></p><h3 id="常见开源实现"><a class="anchor" href="#常见开源实现">#</a> 常见开源实现</h3><p>在大数据生态圈中，主流的应用于 ROLAP 场景的交互式计算引擎包括 Impala 和 Prosto，它们的特点如下：</p><ul><li>Hadoop native（跟 Hadoop 生态系统有完好的结合）<ul><li>可直接在 Hive Metastore 对接，处理 Hive 中的表</li><li>可直接处理存储在 HDFS 和 HBase 中的数据</li></ul></li><li>计算与存储分析：它们仅仅是查询引擎，不提供数据存储服务，所有要处理的数据都存储在第三方系统中，比如 Hive，HDFS 和 HBase 等</li><li>MPP 架构：采用经典的 MPP 架构，具有较好的扩展性，能够对应 TB 甚至 PB 级别数据的交互式查询需求</li><li>嵌套式数据存储：支持常见的列式存储格式，比如 ORC（仅 Presto 支持）和 Parquet（Impala 和 Presto 均支持）</li></ul><p>主流的应用于 MOLAP 场景的交互式计算引擎包括 Druid 和 Kylin，它们的特点如下：</p><ul><li>数据建模：将数据分为纬度和度量两类，且所有查询必须针对以上两类列进行</li><li>数据预计算：为了提高数据查询效率，MOLAP 引擎一般会根据纬度和度量列，预先生成计算结果</li></ul><h2 id="yarn"><a class="anchor" href="#yarn">#</a> YARN</h2><table><thead><tr><th>名词解释</th><th>Apache Yarn（Yet Another Resource Negotiator 的缩写）是 hadoop 集群资源管理器系统，Yarn 从 hadoop 2 引入，最初是为了改善 MapReduce 的实现，但是它具有通用性，同样执行其他分布式计算模式。</th></tr></thead><tbody><tr><td>职责</td><td>资源调度和任务管理</td></tr><tr><td>组件</td><td>RM（ResourceManger），NodeManager（NM），ApplicationMaster（AM），Container（容器）</td></tr></tbody></table><h3 id="背景-2"><a class="anchor" href="#背景-2">#</a> 背景</h3><p>既然说最初是为了改善 MapReduce 的实现，那么有何需要改善的？MapReduce1 中，有如下局限性：</p><ul><li>扩展性差：jobtracker 兼顾<strong>资源管理</strong>和<strong>作业控制跟踪功能跟踪任务</strong>，启动失败或迟缓的任务，记录任务的执行状态，维护计数器），压力大，成为系统的瓶颈</li><li>可靠性差：采用了 <code>master/slave</code> 结构，<strong>master 容易单点故障</strong></li><li>资源利用率低：基于槽位的资源分配模型，槽位是一种粗粒度的资源划分单位，通常<strong>一个任务不会用完一个槽位的资源</strong>，<strong>hadoop1 分为 map slot 和 reduce slot</strong>，而<strong>它们之间资源不共享，造成一些资源空闲</strong>。</li><li>不支持多：不支持多种计算框架并行。</li></ul><p>YARN 很好解决了 MapReduce1 中的局限性：yarn 基本思想：一个全局的资源管理器 ResourceManager 和与每个应用对应的 ApplicationMaster，Resourcemanager 和 NodeManager 组成全新的通用系统，以分布式的方式管理应用程序。</p><h3 id="组件"><a class="anchor" href="#组件">#</a> 组件</h3><p><strong>ResourceManager</strong></p><ul><li>处理客户端请求</li><li>启动 / 监控 ApplicationMaster</li><li>监控 NodeManager</li><li>资源分配与调度</li></ul><p><strong>APPlicationMaster</strong></p><ul><li>程序切分</li><li>为应用程序申请资源，并分配任务</li><li>任务监控与容错</li></ul><p><strong>NodeManager</strong></p><ul><li>单个节点上资源管理</li><li>处理来自 ResourceManager 的命令</li><li>处理来自 ApplicationMaster 的命令</li></ul><p><strong>Container</strong><br>对任务运行环境的抽象，封装了<strong> CPU、内存等多维资源</strong>以及环境变量、启动命令等任务运行相关信息</p><h2 id="kubernetes"><a class="anchor" href="#kubernetes">#</a> Kubernetes</h2><p>kubernetes，简称 K8s。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。当部署完 kubernetes，便拥有了一个完整的集群。</p><blockquote><p>特点</p></blockquote><ul><li>可移植：支持公有云，私有云，混合云，多重云（multi-cloud）</li><li>可扩展：模块化，插件化，可挂载，可组合</li><li>自动化：自动部署，自动重启，自动复制，自动伸缩 / 扩展</li></ul><blockquote><p>组件</p></blockquote><p>一个 kubernetes 集群是由一组 node 机器组成，这些 node 上会运行由 kubernetes 所管理的容器化应用，每个集群至少有一个工作节点。</p><p>工作节点会托管所谓的 Pods，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pods。 为集群提供故障转移和高可用性， 这些控制平面一般跨多主机运行，而集群也会跨多个节点运行。</p><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-22T15:54:11.png" alt=""></p><h2 id="关系代数"><a class="anchor" href="#关系代数">#</a> 关系代数</h2><p><strong>就说一下 join 吧</strong></p><p><img data-src="https://s3.bmp.ovh/imgs/2021/11/78bdfce9a44c5969.jpg" alt=""><br>例如，现在有一个任务让你查询某同学借阅的图书书名及作者，假设在数据库中有 <code>book</code> 表和 <code>borrow</code> 表，要查询图书的书名和作者在 <code>book</code> 表中，但是查找的人是这名同学，所以条件是借阅人为该同学，有关信息在 <code>borrow</code> 表中，因此待查询的对象为 <code>book</code> 表和 <code>borrow</code> 表，查询结果是部分属性列，我们想用选择和投影运算可以解决这个问题，可是这两个关系运算作用的对象应当为一个关系，为了解决这个问题，就可以用笛卡尔积使多个关系合并成一个关系；而连接运算就是在笛卡尔积运算的基础上进行某些选择的结果，根据定义，从两个关系的笛卡尔积中选取属性间满足一定条件的元组；大致分为</p><ul><li>一般连接</li><li>等值连接</li><li>自然连接</li></ul><p><img data-src="https://s3.bmp.ovh/imgs/2021/11/253a79a0196a0b86.jpg" alt=""></p><h3 id="一般连接"><a class="anchor" href="#一般连接">#</a> 一般连接</h3><p>假设两个关系 <code>R</code> 和 <code>S</code> ， <code>A</code> 是 <code>R</code> 中的属性组， <code>B</code> 是 <code>S</code> 中的属性组，这两个属性列数相同，而且取值是可以比较的。<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/f4308458c27c33e8.jpg" alt=""><br>如果有需要计算 <code>R</code> 和 <code>S</code> 的一般连接，连接条件是 <code>C&lt;D</code> ，首先计算两个关系的笛卡尔积， <code>R</code> 关系的每一个元组和 <code>S</code> 关系的每一个元组串接得到新关系 <code>5</code> 列 <code>20</code> 行，在此基础上进行筛选，提取 <code>2、3、4、8</code> 行即为最终结果。<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/ac43301b44fc45ee.jpg" alt=""><br>分析有以下要点：</p><ul><li>两个关系参与</li><li>计算笛卡尔积</li><li>比较两个关系中的属性组</li><li>找出属性间值的比较符合条件的元组</li></ul><h3 id="等值连接"><a class="anchor" href="#等值连接">#</a> 等值连接</h3><p>等值连接运算从 <code>R</code> 和 <code>S</code> 的广义笛卡尔积中选择 <code>R</code> 关系在 <code>A</code> 属性组上的值等于 <code>S</code> 关系在 <code>B</code> 属性上值的元组，需要比较的通常是两个属性列是否相等，即 <code>θ</code> 为 <code>=</code> 。<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/a9aebe4abbe98595.jpg" alt=""><br>对于前面的例子，如果将条件改为 <code>C=D</code> ，也就是查询关系 <code>R</code> 的 <code>C</code> 上和关系 <code>S</code> 的 <code>D</code> 上元素相等的元组进行连接，发现<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/87c45003253f8a45.jpg" alt=""><br>其要点与一般连接不同的是需要选择属性组间值相等的元组。</p><p>在等值连接中有一种特殊情况，也可以比较两关系间某列相同元素的元组，比如<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/0724efc4ee4a09f6.jpg" alt=""></p><h3 id="自然连接"><a class="anchor" href="#自然连接">#</a> 自然连接</h3><p>在上一个例子中，可以发现属性列值重复存储，这样没有意义，可以去掉重复的一列，保留一列 <code>B</code><br><img data-src="https://s3.bmp.ovh/imgs/2021/11/dcc54698eb79656a.jpg" alt=""><br>可以不用注明属性属于哪一个关系，连接运算符下面不用注明选择的条件，这种特殊情况的等值连接被称为自然连接，故给出定义，从 <code>R</code> 和 <code>S</code> 的广义笛卡尔积上选择 <code>R</code> 关系和 <code>S</code> 关系同名属性 <code>B</code> 上值相等的元组</p><p><img data-src="https://s3.bmp.ovh/imgs/2021/11/1b1847bcbf1605b0.jpg" alt=""></p><table><thead><tr><th>等值连接</th><th>自然连接</th></tr></thead><tbody><tr><td>保留重复的属性列</td><td>需要把重复的属性列去掉</td></tr><tr><td>从行的角度进行运算</td><td>同时从行和列的角度进行运算</td></tr><tr><td>相同的分量不一定能是相同的属性名</td><td>相同的分量要求必须是相同的属性名</td></tr></tbody></table><h3 id="外连接"><a class="anchor" href="#外连接">#</a> 外连接</h3><p>在自然连接中，有时候左右两边部分元组的属性无法匹配，合成后直接被删除了，我们将它们称为悬浮元组，而对于外连接来说，相当于对于自然连接的一种扩充，分为左、右、全外连接。自然连接中丢弃的悬浮元组在外连接中会根据左右情况予以保留。</p><p><strong>例如</strong><br><strong>学生表 (左)</strong></p><table><thead><tr><th>学号</th><th>姓名</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>1</td></tr><tr><td>2</td><td>李四</td><td>1</td></tr><tr><td>3</td><td>王五</td><td>2</td></tr></tbody></table><p><strong>成绩表 (右)</strong></p><table><thead><tr><th>学号</th><th>成绩</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>90</td><td>1</td></tr><tr><td>2</td><td>100</td><td>1</td></tr></tbody></table><p><strong>左外连接</strong></p><table><thead><tr><th>学号</th><th>姓名</th><th>成绩</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>90</td><td>1</td></tr><tr><td>2</td><td>李四</td><td>100</td><td>1</td></tr><tr><td>3</td><td>王五</td><td>NULL</td><td>2</td></tr></tbody></table><p><strong>右外连接</strong></p><table><thead><tr><th>学号</th><th>姓名</th><th>成绩</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>90</td><td>1</td></tr><tr><td>2</td><td>李四</td><td>100</td><td>1</td></tr></tbody></table><h2 id="编译原理相关知识"><a class="anchor" href="#编译原理相关知识">#</a> 编译原理相关知识</h2><h3 id="词法分析"><a class="anchor" href="#词法分析">#</a> 词法分析</h3><p><strong>词法分析器在程序编译过程中所处的位置</strong><br><img data-src="https://s3.bmp.ovh/imgs/2021/11/c917f2d23e0958a5.jpg" alt="词法分析器在程序编译过程中所处的位置"></p><p><code>Lexical Analyzer</code> ，输入源程序，扫描器 <code>Scanner</code> 从左至右逐个字符地对源程序进行扫描，产生多个单词符号；单词符号的种类有</p><ul><li>基本字（关键字）： <code>begin</code> 、 <code>repeat</code> 、 <code>for</code> 等程序语言定义好的</li><li>标识符：用来表示各种名字，如变量名、数组名和过程名</li><li>常数：各种类型的常数</li><li>运算符： <code>+、-、*、/</code></li><li>界符： <code>,、;、()、space符</code></li></ul><p>输出的单词符号的表示形式为 <code>(单词种别,单词自身的值)</code> ，单词种别通常用整数编码表示</p><ul><li>若一个种别只有一个单词符号，则种别编码就代表该单词符号，假定基本字、运算符、界符都是一符一种。</li><li>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值</li><li>标识符单列一种，标识符自身的值表示成按机器字节划分的内部码。</li><li>常数按类型分种，常数的值则表示成标准的二进制形式</li></ul><h4 id="如何设计"><a class="anchor" href="#如何设计">#</a> 如何设计</h4><p><img data-src="https://s3.bmp.ovh/imgs/2021/11/a05e8638aa81bbdb.jpg" alt=""></p><h4 id="扫描缓冲区"><a class="anchor" href="#扫描缓冲区">#</a> 扫描缓冲区</h4><p>两个指针分别指向起点和搜索位置，考虑到单词长度超过缓冲区的长度，造成存储不连续，可以分为两个半区互补使用。<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/1630759db08b3e5b.jpg" alt=""><br>如果某单词的结尾在一个半区找不到，那么在下一个半区一定能找得到，所以半区的长度就是程序语言允许的单词最大长度，比如某编程语言的标识符长度不超过 <code>128</code> ，就可以推断出编译器的扫描缓冲区总长度为 <code>256</code> 。</p><h4 id="状态转换图"><a class="anchor" href="#状态转换图">#</a> 状态转换图</h4><p>状态转换图是一张有限方向图，节点代表状态，用圆圈表示，状态之间用箭弧连接，上面的标记（字符）代表射出的结点状态下可能出现的输入字符或字符类，一张转换图只包含有限个状态，其中有一个为初态，至少有一个终态。<br>状态转换图可用于识别一定的字符串，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 <code>α</code> ，则称 <code>α</code> 被该状态转换图所识别。<br><img data-src="https://s3.bmp.ovh/imgs/2021/11/7e2548821698f872.jpg" alt=""><br>终态上的 <code>*</code> 代表最后一个输入的字符不属于刚才读入的单词，将其退回去。</p><p><strong>几点限制，不必使用超前搜索</strong></p><ul><li>所有基本字都是保留字，用户不能用它们作自己的标识符</li><li>基本字作为特殊的标识符来处理，使用保留字表</li><li>如果基本字、标识符和常数（或括号）之间没有确定的运算符或界符作为间隔，则必须使用一个空白符作间隔</li></ul><h3 id="语法分析"><a class="anchor" href="#语法分析">#</a> 语法分析</h3><p>语法分析正是建立在词法分析的基础上，以词法分析识别出的正确单词符号串为输入，判断<strong>是否符合相应的语法规则，同时进行错误处理</strong>，为语义分析和后续步骤做准备。在编译的过程中处于核心地位。执行语法分析的程序称为<strong>语法分析程序</strong>，也称为<strong>语法分析器</strong>。</p><blockquote><p>那么何为文法？</p></blockquote><p>以前上编译原理课，经常说自上而下的语法分析， <strong>文法是描述语言的语法结构的形式规则（即语法规则）</strong>，这些规则必须<strong>准确且可理解</strong>。文法通过<strong>对高级语言的语法规则进行形式化的描述</strong>，从而能够<strong>更加精确的描述高级语言程序的语法结构</strong>，适合描述高级语言语法规则的文法是上下文无关文法。</p><blockquote><p>选用哪条文法规则？</p></blockquote><p>比如已知文法</p><pre><code>E → T|E+T|E-T
T → F|T*F|T/F
F → (E)|i
让你给出下列表达式的最左最右推导
i*(i+i)
i+i*i
</code></pre><p>思想<br><strong>1. 输入待推导的表达式</strong><br><strong>2. 对表达式字符串进行第一行文法判定</strong></p><ul><li>判断是否有 <code>+ or -</code> 运算符<strong>括号内除外</strong>，是则输出 <code>E→E+T or E→E-T</code> ， <code>+</code> 之前的所有字符返回进行 <code>2</code> ， <code>+</code> 之后的字符进行 <code>3</code> ；否则进行下一步。</li><li>输出 <code>E→T</code> ，所有字符串进行 <code>3</code> 。</li></ul><p><strong>3. 对表达式字符串进行第二行文法判定</strong></p><ul><li>判断是否有 <code>* or /</code> 运算符<strong>括号内除外</strong>，是则输出 <code>E→E*T or E→E/T</code> ， <code>+</code> 之前的所有字符返回进行 <code>2</code> ， <code>+</code> 之后的字符进行 <code>3</code> ；否则进行下一步。</li><li>输出 <code>T→F</code> ，所有字符串进行 <code>4</code> 。</li></ul><p><strong>4. 对表达式字符串进行第三行文法判定</strong><br>第一个字符是否为 <code>(</code> ，是则输出 <code>F→(E)</code> ，然后将该字符串的 <code>(</code> 、 <code>)</code> 删除，返回 <code>2</code> ；否则输出 <code>F →i</code> ，操作结束。</p><blockquote><p>针对 LL1 文法</p></blockquote><p>比如对于<strong>自上而下的语法分析</strong>来说，无论是<strong>递归下降子程序法</strong>还是<strong>非递归预测分析法</strong>，他们都只能处理<strong> LL1 文法</strong>。</p><p>根据 LL1 文法的三个条件</p><ul><li>需要消除左递归包括间接左递归</li><li>需要消除回溯</li><li>first 集合和 follow 集合不相交</li></ul><p>所以首先需要重写文法，消除左递归，避免陷入死循环，提取左因子，避免回溯。</p><p>我们知道，直接消除<strong>左递归的一般形式为</strong></p><pre><code>p-&gt;pα|β

p-&gt;βp'
p'-&gt;αp'|ε
</code></pre><p><strong>消除间接左递归</strong><br>对于给定文法 <code>G(S)</code></p><pre><code>S-&gt;Qc|c
Q-&gt;Rb|b
R-&gt;Sa|a
</code></pre><p>对于此文法，不存在直接左递归，但是 <code>S、Q、R</code> 都是间接左递归的。给出一个文法消除左递归的条件</p><ul><li>不含以 <code>ε</code> 为右部的产生式</li><li>不含回路</li></ul><p>满足这两个条件比较容易，接下来的思路就是将间接转化为直接，层层带入，转化为只关于 <code>S</code> 的闭包。<br>比如，把文法 <code>G</code> 中的所有非终结符按任一种顺序排列 <code>P1、	P2、...Pn</code> ，按此顺序执行：<br>从上而下考察每一个产生式 <code>Pi(i∈[i,n])</code> ，将之前的非终结符号 <code>Pj(j∈[1,i-1])</code> 带入 <code>Pi</code> (如果可以带入)；然后可以得到 Pi 的一个产生式，如果存在直接左递归，则消除，否则，开始新的一轮循环，考察 <code>Pi+1</code> 。</p><pre><code>for(从1到n的每个i)&#123;
	for(从1到i-1的每个j)&#123;
		把形如Pi-&gt;Pγ的产生式改成Pi-&gt;δ1γ|δkγ|δ2γ|...|δkγ，其中Pj-&gt;δ1|δk|δ2|...|δk是关于Aj的所有产生式
	&#125;
	消除关于Pi产生式的直接左递归
&#125;
</code></pre><pre><code>S-&gt;Sabc|abc|bc|c
Q-&gt;Sab|ab|b
R-&gt;Sa|a
</code></pre><p><strong>消除回溯</strong></p><p>为了消除回溯必须保证，对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应该是确信无疑的。</p><p><strong>FIRST 集合</strong>：<strong>假设 <code>G</code> 是一个不含左递归的文法</strong>，对 <code>G</code> 的所有非终结符的每个候选 <code>α</code> 定义它的终结首符集 <code>FIRST(α)</code> 为： <code>FIRST(α)=&#123;a|α=*=&gt;a...,a∈Vt&#125;</code> ，特别的，若 <code>α=*=&gt;ε</code> ，则规定 <code>ε∈FIRST(α)</code></p><p>如果非终结符 <code>A</code> 的所有候选首符集两两不相交，即 <code>A</code> 的任何两个不同候选 <code>αi</code> 和 <code>αj</code> ， <code>FIRST(αi)∩FIRST(αj)=Ø</code> ；当要求 <code>A</code> 匹配输入串时， <code>A</code> 能根据它面临的第一个输入符号 <code>a</code> ，准确地指派一个候选去执行任务，这个候选就是那个终结首符集含有 <code>a</code> 的候选式 <code>α</code> ，它是唯一的，因为任何候选首符集两两不相交。</p><p>这样就可以根据当前的终结符找一个唯一可能的候选，可是一个文法可能最开始的时候并不具备一个非终结符的多个候选首符集两两不相交这个条件，可以提取公共左因子来进行改造，来使它具备这个条件。<br><img data-src="https://s3.bmp.ovh/imgs/2021/12/fdb1f1cbfe58ef05.jpg" alt=""></p><p>经过反复提取左因子，就能把每个非终结符 (包括新引进者) 的所有候选首符集变得两两不相交。</p><p><strong>FOLLOW 集合</strong>：假定 <code>S</code> 是文法 <code>G</code> 的开始符号，对于 <code>G</code> 的任何非终结符 <code>A</code> ，我们定义 <code>FOLLOW</code> 集合<br><code>FOLLOW(A)=&#123;a|S=*=&gt;...Aa...,a∈Vt&#125;</code> ，也就是 <code>FOLLOW(A)</code> 集合是所有紧跟 <code>A</code> 之后的终结符或 <code>#</code> 所组成的集合（ <code>#</code> 是句尾的标志），称 <code>FOLLOW(A)</code> 是 <code>A</code> 的随符集。</p><p>计算所有非终结符号 <code>A</code> 的 <code>FOLLOW(A)</code> 集合时，不断应用下面的规则，直到再没有新的终结符号可以被加入到任意的 <code>FOLLOW</code> 集合中为止。<br>注意：当 <code>A</code> 是最右部的时候，将 <code>#</code> 加入到 <code>FOLLOW(A)</code> 中</p><ul><li>将 <code>#</code> 放到 <code>FOLLOW(A)</code> 中， <code>A</code> 是文法的开始符号。</li><li>如果存在一个产生式 <code>A→αBβ</code> ，那么 <code>FIRST(B)</code> 中除 <code>ε</code> 之外的所有符号都在 <code>FOLLOW(B)</code> 中。 <code>FOLLOW(B)</code> 是求跟在 <code>B</code> 后的终结符或 <code>#</code> 组成的集合，因此对于跟在 <code>B</code> 后的 <code>β</code> ，它的 <code>FIRST</code> 集合就是 <code>FOLLOW(B)</code> 的子集。</li><li>如果存在一个产生式 <code>A→αB</code> ，或存在产生式 <code>A→αBβ</code> 且 <code>FIRST(B)</code> 包含 <code>ε</code> ，那么 <code>FOLLOW(A)</code> 中的所有符号都在 <code>FOLLOW(B)</code> 中。对于 <code>A→αBβ</code> ，且 <code>β</code> 多步推导出 <code>ε</code> ，那么可以用 <code>αB</code> 替换 <code>A</code> ， <code>B</code> 后面紧跟的字符就是 <code>A</code> 后面紧跟的字符。</li></ul><p>详情请见：<span class="exturl" data-url="aHR0cHM6Ly9uZXN0aWZ5b2QuZ2l0aHViLmlvLzIwMjEvMDkvMjMvJUU2JUI2JTg4JUU5JTk5JUE0JUU1JTlCJTlFJUU2JUJBJUFGLw==">消除回溯</span></p><h3 id="抽象语法树"><a class="anchor" href="#抽象语法树">#</a> 抽象语法树</h3><p>当在开发语言时，可能在开始的时候，选择 LL1 文法来描述语言的语法规则，编译器前端生成 LL1 语法树，编译器后端对 LL1 语法树进行处理，生成字节码或者是汇编代码。但是随着工程的开发，在语言中加入了更多的特性，用 LL1 文法描述时，感觉限制很大，并且编写文法时很吃力，所以这个时候决定采用 LR1 文法来描述语言的语法规则，把编译器前端改生成 LR1 语法树，但在这个时候，你会发现很糟糕，因为以前编译器后端是对 LL1 语树进行处理，不得不同时也修改后端的代码。</p><p><strong>抽象语法树的第一个特点为</strong>：不依赖于具体的文法。无论是 LL1 文法，还是 LR1，或者还是其它的方法，都要求在语法分析时候，构造出相同的语法树，这样可以给编译器后端提供了清晰，统一的接口。即使是前端采用了不同的文法，都只需要改变前端代码，而不用连累到后端。即减少了工作量，也提高的编译器的可维护性。</p><p><strong>抽象语法树的第二个特点为</strong>：不依赖于语言的细节。在编译器家族中，大名鼎鼎的 gcc 算得上是一个老大哥了，它可以编译多种语言，例如 c，c＋＋，java，ADA，Object C， FORTRAN， PASCAL， COBOL 等等。在前端 gcc 对不同的语言进行词法，语法分析和语义分析后，产生抽象语法树形成中间代码作为输出，供后端处理。要做到这一点，就必须在构造语法树时，不依赖于语言的细节，例如在不同的语言中，类似于 if－condition－then 这样的语句有不同的表示方法。</p><p>其流程即是<strong>词法分析和语法分析</strong>，这两步是从代码生成抽象语法树的关键所在</p><ul><li>词法分析，也叫扫描 scanner<br>它读取我们的代码，然后把它们按照预定的规则合并成一个个的标识 tokens。同时，它会移除空白符、注释等。最后，整个代码将被分割进一个 tokens 列表（或者说一维数组）。当词法分析源代码的时候，它会一个一个字母地读取代码，所以很形象地称之为扫描 - scans。当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。</li><li>语法分析，也称解析器<br>它会将词法分析出来的数组转换成树形的形式，同时，验证语法。语法如果有错的话，抛出语法错误。当生成树的时候，解析器会删除一些没必要的标识 tokens（比如：不完整的括号），因此 AST 不是 100% 与源码匹配的。</li></ul><h2 id="分布式系统中shuffle的实现方式"><a class="anchor" href="#分布式系统中shuffle的实现方式">#</a> 分布式系统中 shuffle 的实现方式</h2><p>MapReduce 的流程，执行过程分为三个环节</p><ul><li>map 阶段负责读取和解析数据，</li><li>shuffle 阶段负责把对应的数据分发给相应的 reducer</li><li>reduce 阶段则做汇总属于自己的数据并做最终业务逻辑处理。</li></ul><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-23T02:03:51.png" alt=""></p><p>大量 IO 导致 MR 性能不佳，如何优化 IO，我们需要关注 shuffle 阶段，整个 shuffle 阶段可以拆成两部分 <code>shuffle write</code> ， <code>shuffle read</code> 。</p><ul><li>shuffle write：mapper 把处理好的数据写到本地磁盘上，一般会以 reduce 好处理的形式组织</li><li>shuffle read：reducer 把分散在各个 mapper 的数据读取到本地并合并</li></ul><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-23T02:11:03.png" alt=""></p><p>由于 shuffle read 在 shuffle write 之后，相对被动，上游写了多少文件，怎么写的，下游就只能相应去处理，所以重点关注 shuffle write，shuffle 的关键在于为每个下游独立输出数据，也就是把每个 reducer 的数据写在一起，能想到每个 mapper 都为每个 reducer 生成一个文件，再把对应数据都写进去，这就是 hash shuffle，分为两种机制，<strong>普通运行机制</strong>和<strong>合并运行机制</strong>，合并机制主要是通过复用 buffer 来优化 shuffle 过程中产生的小文件的数量，<strong>hash shuffle 不具有排序能力</strong>。</p><p>详见：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMDAyMjUzL2FydGljbGUvZGV0YWlscy84Nzk1MjIyNw==">shuffle 机制和原理分析</span></p><h2 id="group-by与join的执行方式"><a class="anchor" href="#group-by与join的执行方式">#</a> group-by 与 join 的执行方式</h2><p>MySQL 中，group by 用来分组，根据一个或多个列对结果集进行分组，使得对数据的分类更加精确；join 则用于获取两个表中匹配的关系</p><p>hive 是用来分析 hdfs 上的结构化数据的非交互式的数据仓库，解决数据冗余，hive 最终被编译成 MapReduce，通过 SQL 执行 MapReduce。</p><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-23T02:48:18.png" alt=""></p><table><thead><tr><th>name</th><th>rank</th></tr></thead><tbody><tr><td>Java</td><td>1</td></tr><tr><td>Java</td><td>2</td></tr><tr><td>Java</td><td>1</td></tr><tr><td>...</td><td>...</td></tr><tr><td>Hive</td><td>2</td></tr><tr><td>Java</td><td>1</td></tr><tr><td>Hive</td><td>2</td></tr><tr><td>...</td><td>...</td></tr></tbody></table><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>	name</pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token punctuation">,</span>rank</pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 	<span class="token keyword">AS</span> cnt </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">FROM</span> TEST </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> rank<span class="token punctuation">;</span></pre></td></tr></table></figure><p>Map 阶段的 key 即是 <code>group by</code> 字段的组合</p><p><img data-src="https://cdn.fygod.xyz/blog/nest/2022-07-23T02:48:33.png" alt=""></p><p><strong>t_student</strong></p><table><thead><tr><th>student</th><th>rank_id</th></tr></thead><tbody><tr><td>Arvin</td><td>1</td></tr><tr><td>Jin</td><td>1</td></tr><tr><td>Bob</td><td>2</td></tr></tbody></table><p><strong>t_rank</strong></p><table><thead><tr><th>rank_id</th><th>rank</th></tr></thead><tbody><tr><td>1</td><td>good</td></tr><tr><td>2</td><td>bad</td></tr></tbody></table><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	t<span class="token punctuation">.</span>student</pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token punctuation">,</span>tt<span class="token punctuation">.</span>rank</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">FROM</span> t_student t</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">JOIN</span> t_rank tt</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">on</span> t<span class="token punctuation">.</span>rank_id <span class="token operator">=</span> tt<span class="token punctuation">.</span>rank_id<span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="常见的查询优化器"><a class="anchor" href="#常见的查询优化器">#</a> 常见的查询优化器</h1><p>单机环境要求不高，对于大数据的应用，查询优化很重要</p><h2 id="top-down-optimizer"><a class="anchor" href="#top-down-optimizer">#</a> Top-down Optimizer</h2><p><span class="exturl" data-url="aHR0cHM6Ly8xNTcyMS5jb3Vyc2VzLmNzLmNtdS5lZHUvc3ByaW5nMjAxOC9wYXBlcnMvMTUtb3B0aW1pemVyMS94dS1jb2x1bWJpYS10aGVzaXMxOTk4LnBkZg==">论文</span>中给出的实现是一个自顶向下（top-down）的递归算法，在每个递归节点上，可以通过某些规则决定 apply 规则的先后顺序。这样做的好处是，如果不希望遍历整个搜索空间，该策略能够在给定的有限步数内给出较优解。但代价则是代码逻辑变得十分难懂，也无法进行进行剪枝优化。从使用者的角度看，原本 top-down 优化中 apply rule 一定是先父节点、后子节点，而 Calcite 中的优化则是 “随机” 发生在 plan tree 的各个节点上，这也给编写 rule 带来了一些麻烦。</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9lcmljZnUubWUvY2FsY2l0ZS10b3AtZG93bi1wbGFubmVyLw==">Calcite 中新增的 Top-down 优化器</span>，核心逻辑看不懂</p><p>&lt;!-- ## Bottom-up Optimizer</p><h2 id="rule-based-optimizerrbo"><a class="anchor" href="#rule-based-optimizerrbo">#</a> Rule-based Optimizer，RBO</h2><ul><li>Rule</li><li>Pattern</li></ul><h2 id="cost-based-optimizercbo"><a class="anchor" href="#cost-based-optimizercbo">#</a> Cost-based Optimizer，CBO</h2><ul><li>动态规划</li></ul><h2 id="交换律-结合律-传递性"><a class="anchor" href="#交换律-结合律-传递性">#</a> 交换律、结合律、传递性</h2><h2 id="rbo-优化规则"><a class="anchor" href="#rbo-优化规则">#</a> RBO 优化规则</h2><ul><li>列裁剪</li><li>谓词下推</li><li>传递闭包</li><li>Runtime Filter（min-max filter，in-list filter，bloom filter）</li><li>Join 消除</li><li>谓词合并</li></ul><h2 id="cbo-相关概念"><a class="anchor" href="#cbo-相关概念">#</a> CBO 相关概念</h2><ul><li>统计信息<ul><li>Number of Distinct Value，NDV</li><li>Selectivity</li><li>Cardinality</li></ul></li><li>代价模型</li></ul><h1 id="查询优化器的社区开源实践"><a class="anchor" href="#查询优化器的社区开源实践">#</a> 查询优化器的社区开源实践</h1><h2 id="apache-calcite"><a class="anchor" href="#apache-calcite">#</a> Apache Calcite</h2><h2 id="orca"><a class="anchor" href="#orca">#</a> Orca</h2><h2 id="volcanocascade-框架"><a class="anchor" href="#volcanocascade-框架">#</a> Volcano/Cascade 框架</h2><ul><li>Memo</li><li>AND/OR Graph</li><li>Expression group</li><li>Group expression</li><li>Pattern</li><li>Rule</li><li>Branch-and-Bound Pruning</li><li>Winner --&gt;</li></ul><h1 id="sql相关的前沿趋势"><a class="anchor" href="#sql相关的前沿趋势">#</a> SQL 相关的前沿趋势</h1><h2 id="存储计算分离"><a class="anchor" href="#存储计算分离">#</a> 存储计算分离</h2><p>我们知道 CPU 是由控制器、运算器和寄存器组成的，我们在运行一段程序的时候我们的指令是存储在我们的存储器的，我们所执行的每一个步骤都和存储分离不开。</p><p>计算和存储分离并不是现在才出现的一个新名词，在 20 年前就有 NAS - 网络附加存储这个东西，本质上也就是使用 TCP/IP 协议的以太网文件服务器。当时如果想要大规模的存储，就会让服务器将数据保存到 NAS 这个上面，但是 NAS 价格及其昂贵，并且扩展比较困难，NAS 也就不适用于高速发展的互联网应用。</p><p>这个时候谷歌摒弃了之前的观念 “移动存储到计算”，采取了 “移动计算到存储的观念”，将计算和存储耦合了，因为当时的网络速度对比现在来说慢了几百倍，网络速度跟不上我们的需要。在典型的 MapReduce 部署中计算和存储都在同一个集群中进行，比如后续的 hadoop。这里其实也就是用<strong>本地 IO 速度来替换网络传输速度</strong>。</p><p>随着技术的进步，我们的网络速度也越来越快，我们的瓶颈不再是网络速度，但是我们的磁盘 I/O 速度却没有明显的速度增长，计算和存储融合的架构缺点也再逐渐暴露，由于计算和存储耦合的缺点越来越多，并且网络速度越来越快，现在架构又在重新向计算和存储分离这一方向重新开始发展。</p><p>应用于数据库和消息队列。</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDc1MjY2NjI=">MySQL 存算分离解析（杂谈）</span> &amp; <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpNTYzODY4MjczL2FydGljbGUvZGV0YWlscy8xMDQxNjQzNTYv">聊聊计算和存储分离</span></p><h2 id="hsap-htap-htsap"><a class="anchor" href="#hsap-htap-htsap">#</a> HSAP, HTAP, HTSAP</h2><p>HSAP 与 HTAP 都会成为企业数据架构中不可或缺的重要组成部分，而在应对有规模企业，特别是当互联网 / 物联网应用不断扩大时，企业分析查询对大数据有着越来越高的需求，那么这时，HSAP 就有了其更加不可或缺的作用。而对 HTAP 数据库来讲，虽然在技术实现上并不会太简单，但从本质上讲，HTAP 在对其分布式事务能力进行妥协后，应该也有同时具备 HSAP 能力的潜能。</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUzNzczMzAyL2FydGljbGUvZGV0YWlscy8xMjI1MjUzOTQ=">关于 HTAP 与 HSAP</span></p><h2 id="cloud-native-serverless"><a class="anchor" href="#cloud-native-serverless">#</a> Cloud Native, Serverless</h2><p><strong>关于云原生和无服务器之间的联系</strong></p><p>云原生比云计算多了一个 native，阿里某位大佬说过：“因云而生的软件，硬件，架构，就是真正的云原生，因云而生的技术，就是云原生技术。”</p><p>云原生是一个更加泛的概念，他表示的是在云计算领域中的一部分，是在云且原生的部分。那么 Serverless 架构呢，它本身也是因云而生，成长在云，Serverless 架构是一种技术架构，而云原生是一种泛概念，他的外面还有云计算。</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5OTcwMjc5MQ==">Cloud Native （云原生）和 Severless （无服务器）之间具体有怎样的联系？</span></p><h2 id="数据仓库数据湖湖仓一体联邦查询"><a class="anchor" href="#数据仓库数据湖湖仓一体联邦查询">#</a> 数据仓库，数据湖，湖仓一体，联邦查询</h2><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjgwOS9hcnRpY2xlL2RldGFpbHMvMTI0OTc5Mjk0">一文读懂数据仓库、数据湖、湖仓一体</span></p><h3 id="数据仓库"><a class="anchor" href="#数据仓库">#</a> 数据仓库</h3><p>Data Warehouse（DW/DWH），早期系统采用关系型数据库来存放管理数据，但是随着大数据技术的兴起，人们对于多方面数据进行分析的需求愈加强烈，这就要求建立一个能够面向分析、集成保存大量历史数据的新型管理机制，这一机制就是数据仓库。</p><p>数据仓库通常存储来自<strong>不同源</strong>的数据，集成源数据以<strong>提供统一的视图</strong>。这些资源可以包<strong>括事务系统、应用程序日志文件、关系数据库</strong>等等。</p><p><strong>特征</strong></p><ul><li>数据仓库的数据是面向主题的</li><li>数据仓库的数据是集成的</li><li>数据仓库的数据是随时间不断变化的</li><li>数据仓库的数据是非易失的</li></ul><h3 id="数据湖"><a class="anchor" href="#数据湖">#</a> 数据湖</h3><p>Data Lake 是一个以<strong>原始格式存储数据</strong>的<strong>存储库或系统</strong>，它按原样存储数据，而无需事先对数据进行结构化处理。<strong>无论是否结构化或半结构化亦或是二进制数据如图形，音频，视频都可以存</strong>。</p><p><strong>特征</strong></p><ul><li>容量大</li><li>格式多</li><li>处理速度快</li><li>体系结构，数据湖是由多个组件构成的生态系统</li></ul><p><strong>Hadoop 相比于数据湖，虽然 Hadoop 基于分布式，可横向扩展文件系统架构，可以管理和处理海量数据，但是它无法提供数据湖所需要的复杂元数据管理功能。根据数据湖的体系结构，数据湖是由多个组件构成的生态系统，而 Hadoop 仅仅提供了其中的部分组件功能。</strong></p><h3 id="湖仓一体"><a class="anchor" href="#湖仓一体">#</a> 湖仓一体</h3><p>数据湖虽然适合数据的存储，但是缺少一些关键功能，不支持事务，缺乏一致性，隔离性，不能保证执行数据质量，这样的短板决定了，<strong>让数据湖来承载读写访问、批处理、流作业是不现实的</strong>。而且，<strong>数据湖缺乏结构性，一旦没有被治理好，就会变成数据沼泽</strong>。</p><p>既然都是拿数据为业务服务，数据湖和数仓作为两大 “数据集散地”，能不能彼此整合一下，让数据流动起来，少点重复建设呢？，于是，Databricks 率先提出了湖仓一体（Data Lakehouse）的概念。</p><p>湖仓一体是一种结合了数据湖灵活性和数据仓库规范性优势的新范式，在基于数据湖的低成本存储上，实现与数据仓库中类似的数据结构和数据管理功能。</p><p>Data Lakehouse 的出现试图去融合数仓和数据湖这两者之间的差异，通过将数仓构建在数据湖上，使得存储变得更为廉价和弹性，同时 lakehouse 能够有效地提升数据质量，减小数据冗余。</p><p>在 lakehouse 的构建中，ETL（Extract-Transform-Load）起了非常重要的作用，它能够将未经规整的数据湖层数据转换成数仓层结构化的数据。</p><p><strong>特征</strong></p><ul><li>支持事务，可以处理多条不同的数据管道，意味着它可以在不破坏数据完整性的前提下支持并发的读写事务</li><li>根据应用需求为绝大多数数据施加 schemas，标准化</li><li>报表以及分析应用的支持</li><li>数据类型扩展，这一点结合数据湖的优势</li><li>端到端的流式支持，支持流式分析，从而能够满足实时报表的需求</li><li>计算存储分离，数据存储在一个集群中，而在另一个集群中进行处理</li><li>开放性（跨构件，引擎，语言操作）</li></ul><p>&lt;!-- ### 联邦查询 --&gt;</p><p>&lt;!-- ## 智能化：AI4DB，DB4AI --&gt;</p><div class="tags"><a href="/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/" rel="tag"><i class="ic i-tag"></i> 青训营</a> <a href="/tags/%E8%AF%BE%E5%89%8D%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 课前笔记</a> <a href="/tags/SQL-optimizer/" rel="tag"><i class="ic i-tag"></i> SQL optimizer</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新於</span> <time title="修改時間：2022-07-24 10:01:25" itemprop="dateModified" datetime="2022-07-24T10:01:25+08:00">2022-07-24</time> </span><span id="2022/07/22/SQL查询优化器浅析（课前）/" class="item leancloud_visitors" data-flag-title="SQL查询优化器浅析（课前）" title="閱讀次數"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">閱讀次數</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 打賞</button><p>請我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="fygod 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="fygod 支付寶"><p>支付寶</p></div><div><img data-src="/images/paypal.png" alt="fygod PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>博主： </strong>fygod <i class="ic i-at"><em>@</em></i>2022</li><li class="link"><strong>文章連結：</strong> <a href="https://fygod1999.github.io/2022/07/22/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/" title="SQL查询优化器浅析（课前）">https://fygod1999.github.io/2022/07/22/SQL查询优化器浅析（课前）/</a></li><li class="license"><strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 許可協議。轉載請註明出處！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/07/22/2022-7-22/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2022&#x2F;07&#x2F;20&#x2F;jHsjOg.jpg" title="2022.7.22"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 雅思分手计划</span><h3>2022.7.22</h3></a></div><div class="item right"><a href="/2022/07/23/2022-7-23/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.fygod.xyz&#x2F;blog&#x2F;nest&#x2F;Y4m35hX4_wallhaven-o38yol-compressed.jpg" title="2022.7.23"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 雅思分手计划</span><h3>2022.7.23</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目錄"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB%E5%92%8Csql"><span class="toc-number">1.</span> <span class="toc-text">大数据体系和 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.</span> <span class="toc-text">火山引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%92%8C%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">批式计算和流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.</span> <span class="toc-text">交互式分析引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">常见开源实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yarn"><span class="toc-number">1.4.</span> <span class="toc-text">YARN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubernetes"><span class="toc-number">1.5.</span> <span class="toc-text">Kubernetes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">关系代数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">一般连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">等值连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">自然连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.4.</span> <span class="toc-text">外连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">1.7.</span> <span class="toc-text">编译原理相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.7.1.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">如何设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">扫描缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">状态转换图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.7.2.</span> <span class="toc-text">语法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">1.7.3.</span> <span class="toc-text">抽象语法树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%ADshuffle%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">分布式系统中 shuffle 的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by%E4%B8%8Ejoin%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">group-by 与 join 的执行方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">常见的查询优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#top-down-optimizer"><span class="toc-number">2.1.</span> <span class="toc-text">Top-down Optimizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rule-based-optimizerrbo"><span class="toc-number">2.2.</span> <span class="toc-text">Rule-based Optimizer，RBO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cost-based-optimizercbo"><span class="toc-number">2.3.</span> <span class="toc-text">Cost-based Optimizer，CBO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%BE%8B-%E7%BB%93%E5%90%88%E5%BE%8B-%E4%BC%A0%E9%80%92%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">交换律、结合律、传递性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rbo-%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">2.5.</span> <span class="toc-text">RBO 优化规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cbo-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text">CBO 相关概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E7%A4%BE%E5%8C%BA%E5%BC%80%E6%BA%90%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.</span> <span class="toc-text">查询优化器的社区开源实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-calcite"><span class="toc-number">3.1.</span> <span class="toc-text">Apache Calcite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orca"><span class="toc-number">3.2.</span> <span class="toc-text">Orca</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volcanocascade-%E6%A1%86%E6%9E%B6"><span class="toc-number">3.3.</span> <span class="toc-text">Volcano&#x2F;Cascade 框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E7%9B%B8%E5%85%B3%E7%9A%84%E5%89%8D%E6%B2%BF%E8%B6%8B%E5%8A%BF"><span class="toc-number">4.</span> <span class="toc-text">SQL 相关的前沿趋势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%A1%E7%AE%97%E5%88%86%E7%A6%BB"><span class="toc-number">4.1.</span> <span class="toc-text">存储计算分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hsap-htap-htsap"><span class="toc-number">4.2.</span> <span class="toc-text">HSAP, HTAP, HTSAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cloud-native-serverless"><span class="toc-number">4.3.</span> <span class="toc-text">Cloud Native, Serverless</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%95%B0%E6%8D%AE%E6%B9%96%E6%B9%96%E4%BB%93%E4%B8%80%E4%BD%93%E8%81%94%E9%82%A6%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.4.</span> <span class="toc-text">数据仓库，数据湖，湖仓一体，联邦查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="toc-number">4.4.1.</span> <span class="toc-text">数据仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B9%96"><span class="toc-number">4.4.2.</span> <span class="toc-text">数据湖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B9%96%E4%BB%93%E4%B8%80%E4%BD%93"><span class="toc-number">4.4.3.</span> <span class="toc-text">湖仓一体</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/07/22/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/" rel="bookmark" title="SQL查询优化器浅析（课前）">SQL查询优化器浅析（课前）</a></li><li><a href="/2022/07/25/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E4%B8%AD%EF%BC%89/" rel="bookmark" title="SQL查询优化器浅析（课中）">SQL查询优化器浅析（课中）</a></li><li><a href="/2022/07/26/%E6%B5%81%E6%89%B9OLAP-%E4%B8%80%E4%BD%93%E7%9A%84Flink%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/" rel="bookmark" title="流批OLAP 一体的Flink引擎介绍（课前）">流批OLAP 一体的Flink引擎介绍（课前）</a></li></ul></div><div class="overview panel" data-title="本站概覽"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="fygod" data-src="/images/avatar.jpg"><p class="name" itemprop="name">fygod</p><div class="description" itemprop="description">孤舟蓑笠翁，獨釣寒江雪</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">76</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分類</span></a></div><div class="item tags"><a href="/tags/"><span class="count">88</span> <span class="name">標籤</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z5Z29kMTk5OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;fygod1999"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9GWUdPRFlG" title="https:&#x2F;&#x2F;twitter.com&#x2F;FYGODYF"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dS14aW5nLXRpYW4teGlhLTE2" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tu-xing-tian-xia-16"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE5NDM1NzQ4NDg=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1943574848"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNzIxMzIyNjQyOQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;7213226429"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjIyMjY3NjI3OTVAcXEuY29t" title="mailto:2226762795@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首頁</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>歸檔</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分類</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>標籤</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-cloud"></i>傳送</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友鏈</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>網址</a></li></ul></li><li class="item"><a href="/comments/" rel="section"><i class="ic i-paper-plane"></i>留言</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/07/22/2022-7-22/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/07/23/2022-7-23/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>隨機文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/" title="分類於 盲人摸象">盲人摸象</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E7%8F%AD/" title="分類於 大数据基础班">大数据基础班</a></div><span><a href="/2022/07/22/SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%EF%BC%88%E8%AF%BE%E5%89%8D%EF%BC%89/" title="SQL查询优化器浅析（课前）">SQL查询优化器浅析（课前）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/" title="分類於 盲人摸象">盲人摸象</a></div><span><a href="/2021/06/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" title="进程间通信">进程间通信</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A0%B4%E9%87%9C%E6%B2%89%E8%88%9F/" title="分類於 破釜沉舟">破釜沉舟</a></div><span><a href="/2022/06/30/2022.6.30/" title="2022.6.30">2022.6.30</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A0%B4%E9%87%9C%E6%B2%89%E8%88%9F/" title="分類於 破釜沉舟">破釜沉舟</a></div><span><a href="/2022/07/06/2022.7.6/" title="2022.7.6">2022.7.6</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/" title="分類於 盲人摸象">盲人摸象</a></div><span><a href="/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="二叉树中的最大路径和">二叉树中的最大路径和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8C%97%E5%86%A5%E6%9C%89%E9%B1%BC/" title="分類於 北冥有鱼">北冥有鱼</a></div><span><a href="/2022/06/03/%E5%90%91%E9%87%8F/" title="向量">向量</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A0%B4%E9%87%9C%E6%B2%89%E8%88%9F/" title="分類於 破釜沉舟">破釜沉舟</a></div><span><a href="/2022/06/27/2022.6.27/" title="2022.6.27">2022.6.27</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A0%B4%E9%87%9C%E6%B2%89%E8%88%9F/" title="分類於 破釜沉舟">破釜沉舟</a></div><span><a href="/2022/07/05/2022.7.5/" title="2022.7.5">2022.7.5</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A0%B4%E9%87%9C%E6%B2%89%E8%88%9F/" title="分類於 破釜沉舟">破釜沉舟</a></div><span><a href="/2022/06/17/2022.6.17/" title="2022.6.17">2022.6.17</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%B5%B7%E5%9B%BD%E5%9B%BE%E5%BF%97/" title="分類於 海国图志">海国图志</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%B5%B7%E5%9B%BD%E5%9B%BE%E5%BF%97/%E9%9B%85%E6%80%9D%E5%88%86%E6%89%8B%E8%AE%A1%E5%88%92/" title="分類於 雅思分手计划">雅思分手计划</a></div><span><a href="/2022/07/22/2022-7-22/" title="2022.7.22">2022.7.22</a></span></li></ul></div><div><h2>最新評論</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">fygod @ Scarecrow</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站點總字數">308k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站點閱讀時長">4:40</span></div><div class="powered-by">基於 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/07/22/SQL查询优化器浅析（课前）/",favicon:{show:"（●´3｀●）復活成功",hide:"(´Д｀) 瀏覽器崩潰啦"},search:{placeholder:"文章搜索",empty:"關於 「 ${query} 」 ，什麼也沒搜到",stats:"${time} ms 內找到 ${hits} 條結果"},valine:!0,fancybox:!0,copyright:'複製成功，轉載請遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 協議。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->